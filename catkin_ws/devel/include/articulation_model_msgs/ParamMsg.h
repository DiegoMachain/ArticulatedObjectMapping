// Generated by gencpp from file articulation_model_msgs/ParamMsg.msg
// DO NOT EDIT!


#ifndef ARTICULATION_MODEL_MSGS_MESSAGE_PARAMMSG_H
#define ARTICULATION_MODEL_MSGS_MESSAGE_PARAMMSG_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace articulation_model_msgs
{
template <class ContainerAllocator>
struct ParamMsg_
{
  typedef ParamMsg_<ContainerAllocator> Type;

  ParamMsg_()
    : name()
    , value(0.0)
    , type(0)  {
    }
  ParamMsg_(const ContainerAllocator& _alloc)
    : name(_alloc)
    , value(0.0)
    , type(0)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _name_type;
  _name_type name;

   typedef double _value_type;
  _value_type value;

   typedef uint8_t _type_type;
  _type_type type;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(PRIOR)
  #undef PRIOR
#endif
#if defined(_WIN32) && defined(PARAM)
  #undef PARAM
#endif
#if defined(_WIN32) && defined(EVAL)
  #undef EVAL
#endif

  enum {
    PRIOR = 0u,
    PARAM = 1u,
    EVAL = 2u,
  };


  typedef boost::shared_ptr< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> const> ConstPtr;

}; // struct ParamMsg_

typedef ::articulation_model_msgs::ParamMsg_<std::allocator<void> > ParamMsg;

typedef boost::shared_ptr< ::articulation_model_msgs::ParamMsg > ParamMsgPtr;
typedef boost::shared_ptr< ::articulation_model_msgs::ParamMsg const> ParamMsgConstPtr;

// constants requiring out of line definition

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::articulation_model_msgs::ParamMsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::articulation_model_msgs::ParamMsg_<ContainerAllocator1> & lhs, const ::articulation_model_msgs::ParamMsg_<ContainerAllocator2> & rhs)
{
  return lhs.name == rhs.name &&
    lhs.value == rhs.value &&
    lhs.type == rhs.type;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::articulation_model_msgs::ParamMsg_<ContainerAllocator1> & lhs, const ::articulation_model_msgs::ParamMsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace articulation_model_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "6b116ef40eb37aa2f03e65c1a95f8bf1";
  }

  static const char* value(const ::articulation_model_msgs::ParamMsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x6b116ef40eb37aa2ULL;
  static const uint64_t static_value2 = 0xf03e65c1a95f8bf1ULL;
};

template<class ContainerAllocator>
struct DataType< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "articulation_model_msgs/ParamMsg";
  }

  static const char* value(const ::articulation_model_msgs::ParamMsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Single parameter passed to or from model fitting\n"
"#\n"
"# This mechanism allows to flexibly pass parameters to \n"
"# model fitting (and vice versa). Note that these parameters \n"
"# are model-specific: A client may supply additional\n"
"# parameters to the model estimator, and, similarly, a estimator\n"
"# may add the estimated model parameters to the model message.\n"
"# When the model is then evaluated, for example to make predictions\n"
"# or to compute the likelihood, the model class can then use\n"
"# these parameters.\n"
"#\n"
"# A parameter has a name, a value, and a type. The type globally\n"
"# indicates whether it is a prior parameter (prior to model fitting),\n"
"# or a model parameter (found during model fitting, using a maximum-\n"
"# likelihood estimator), or a cached evaluation (e.g., the likelihood\n"
"# or the BIC are a typical \"side\"-product of model estimation, and\n"
"# can therefore already be cached).\n"
"#\n"
"# For a list of currently used parameters, see the documentation at\n"
"# http://www.ros.org/wiki/articulation_models\n"
"#\n"
"\n"
"uint8 PRIOR=0   # indicates a prior model parameter \n"
"                # (e.g., \"sigma_position\")\n"
"uint8 PARAM=1   # indicates a estimated model parameter \n"
"                # (e.g., \"rot_radius\", the estimated radius)\n"
"uint8 EVAL=2    # indicates a cached evaluation of the model, given \n"
"                # the current trajectory\n"
"                # (e.g., \"loglikelihood\", the log likelihood of the\n"
"                # data, given the model and its parameters)\n"
"\n"
"string name     # name of the parameter\n"
"float64 value   # value of the parameter\n"
"uint8 type      # type of the parameter (PRIOR, PARAM, EVAL)\n"
"\n"
;
  }

  static const char* value(const ::articulation_model_msgs::ParamMsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.name);
      stream.next(m.value);
      stream.next(m.type);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ParamMsg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::articulation_model_msgs::ParamMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::articulation_model_msgs::ParamMsg_<ContainerAllocator>& v)
  {
    s << indent << "name: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.name);
    s << indent << "value: ";
    Printer<double>::stream(s, indent + "  ", v.value);
    s << indent << "type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.type);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ARTICULATION_MODEL_MSGS_MESSAGE_PARAMMSG_H
